# 3-1 명령어

고급언어 → 변환 → 저급언어

고급언어 ex) 파이썬, c++, java

이런 소스코드는 컴퓨터에서 저급언어로 바뀌어서 이해함

저급언어는 명령어

### 고급언어

- 개발자가 이해하기 쉽게 만든 언어

### 저급언어

- 컴퓨터가 이해하고 실행하는 언어

### 저급언어

- 기계어
- 어셈블리어

두가지로 나뉜다. 

0, 1로 이루어진 기계어 

이진법 기계어를 읽기 편한 형태로 번역한 것이 어셈블리어

![스크린샷 2024-05-19 오후 11.10.45.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/adfbfd40-8b0e-435b-b6a7-2b7fbcd9492b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.10.45.png)

어셈블리어는 소스코드에 직접 명시해서 사용하기도 한다. 

우리가 사용하는 c언어, c++, python, java 등이 고급언어인데

저급언어로 변환하는 방식에는 두가지가 있다. 

컴파일 언어 → 컴파일 → 저급언어

인터프리터 언어 → 인터프리트 → 저급언어

![스크린샷 2024-05-19 오후 11.13.24.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/69b7fd2e-ecd9-49c3-8a24-a52e25f387af/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.13.24.png)

### 인터프리터 언어

- 인터프리터에 의해 한 줄씩 진행
- 소스코드 전체가 저급언어로 변환되기까지 기다릴 필요가 없음

### 특징

컴파일은 전체를 하기 때문에 중간에 오류가 발생하면 소스코드 전체가 실행되지않음

인터프리터는 진행하다가 오류에서 멈춤

모든 프로그래밍 언어가 컴파일, 인터프리터 언어로 구분되지는 않는다. 

# 3-2 명령어의 구조

명령어의 기본 구조는 무엇을 대상으로, 무엇을 수행해라

![스크린샷 2024-05-19 오후 11.22.52.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/59c36fdb-0f18-42b4-815d-704f44f42d27/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.22.52.png)

        연산코드    +     오퍼랜드로 이루어져 있음

### 오퍼랜드

- 연산에 사용될 데이터
- 연산에 사용될 데이터가 저장된 위치(더 많이 사용됨, 주소필드라고 부름)

*오퍼랜드는 없는경우도, 하나 이상인 경우도 있다. 

### 연산코드

- 데이터전송
- 산술/논리연산
- 제어흐름 변경
- 입출력 제어

## 대표적인 연산 코드의 종류

### 데이터 전송(외울필요 없음)

Move : 데이터를 옮겨라

Store: 메모리에 저장하라

Load: 메모리에서 cpu로 데이터를 가져와라

Push: 스택에 데이터를 저장하라

Pop: 스택의 최상단 데이터를 가져와라 

### Stack : 한쪽끝이 막혀있는 통과 같은 자료구조(last in first out,  LIFO)

![스크린샷 2024-05-19 오후 11.29.03.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/99493b21-c51b-4760-b38f-02618df2a6dd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.29.03.png)

### queue: 양쪽이 뚫여있어서 들어온 순서대로 나가는 자료구조(first in first out, FIFO)

![스크린샷 2024-05-19 오후 11.30.59.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/5cb309b2-9078-4468-90b7-a4a6fc6c2d86/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.30.59.png)

### 산술/논리 연산

- ADD/ SUBJECT/ MULTIPLY/ DIVEIDE: 덧셈/ 뺄셈/ 곱셈/ 나눗셈을 수행하라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
- AND / OR / NOT : 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 True / False 값을 비교하라

### 제어 흐름 변경

- JUMP : 특정 주소로 실행순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정주소로 실행순서를 옮겨라
- HALT :프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행순서를 옮겨라
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라

### 입출력 제어

- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

### 명령어 주소 지정방식

- 같은 16비트 속에 연산코드가 있고 오퍼랜드가 있을때 오퍼랜드의 수가 많아질 수록 하나의 오퍼랜드가 표현할 수 있는 수는 적어진다. 2^4승 만큼의 정보만 입력이 가능하다. 하지만 메모리 주소를 입력하면 이런식으로 표현이 가능해진다.

![스크린샷 2024-05-20 오전 9.47.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/ab02218f-ef0c-4519-9a52-ea3b587c8fee/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-20_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.47.42.png)

### *유효주소 : 연산에 사용할 데이터가 저장된 위치

### 명령어 주소 지정방식

연산에 사용할 데이터가 저장된 위치를 찾는 방법

### 유효주소를 찾는 방법

다양한 명령어 주소지정 방식들

## 명령어 주소 지정방식의 종류

### 즉시 주소지정 방식

- 
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 가장 간단한 형태의 주소 지정방식
    - 연산에 사용할 데이터의 크기가 작아질수 있지만, 빠름

### 직접 주소지정방식

- 
    
    오퍼랜드 필드에 유효주소 직접적으로 명시
    
    유효주소를 표현할 수 있는 크기가 연산코드만큼 줄어듦
    
    ![스크린샷 2024-05-20 오전 9.56.01.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/a4310df1-5792-48c3-bf09-96b686c70daf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-20_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.56.01.png)
    

### 간접 주소지정방식

- 
    
    오퍼랜드 필드에 유효주소의 주소를 명시
    
    앞선 주소지정 방식들에 비해 속도가 느림(메모리를 최소화하는게 속도면에서는 무조건 좋음)
    
    ![스크린샷 2024-05-20 오전 9.56.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/d2840635-9da0-4141-ad4e-17c8bff22565/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-20_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.56.21.png)
    

### 레지스터 직접 주소지정방식

- 
    
    연산에 사용할 데이터가 저장된 레지스터 명시
    
    메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름(기억할것)_
    
    ![스크린샷 2024-05-20 오전 9.58.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/7ba66a9b-8cff-4af8-beae-0b0b83c36a66/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-20_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.58.20.png)
    

### 레지스터 간접 주소지정 방식

- 
    
    연산에 사용할 데이터를 메모리에 저장
    
    그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
    
    ![스크린샷 2024-05-20 오전 10.00.03.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/3d16886e-fa69-40dd-91d2-81ce5624693e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-20_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.00.03.png)
    

# 3-3 c언어의 컴파일 과정

c 언어 컴파일 과정

전처리기(preprocessor) - 컴파일러(compiler) - 어셈블러(assembler) -  링커(linker)

c언어 파일이 주어지면 위의 과정을 한번에 

---

test.c  — 전처리기  —  test.i — 컴파일러(compiler) —— 어셈블러(assembler) —— 링커(linker) 

---

전처리 과정 

- 본격적으로 컴파일 하기전에 처리할 작업들
- 외부에 선언된 다양한 소스코드, 라이프러리 포함
- 프로그래밍의 편의를 위해 작성된 매크로 변환
- 컴파일할 영역 명시
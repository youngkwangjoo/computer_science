- ALU와 제어장치
    
    ![스크린샷 2024-05-24 오전 9.25.10.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/d600152b-8afc-43e9-a7a4-cabc805da45b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.25.10.png)
    
    ALU는 계산하는 장치
    
    제어장치는 제어신호를 발생시키고 명령어를 해석하는 장치
    
    ALU의 구조
    
    ![스크린샷 2024-05-24 오전 9.27.45.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/93e321e2-35fc-4968-bad9-ef4dc0a2240a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.27.45.png)
    
    계산을 하기위해서는 피연산자와 수행할 연산이 필요 
    
    계산할 값, 한 값을 레지스터에 임시로 담아서 필요한데 사용한다. 
    
    플래그는 연산 결과에 대한 부가 정보를 담음
    
    이전에 같은 숫자에 음수와 양수가 있을 경우 어떻게 구분하는가에 대한 질문으로 플래그에 음수값을 담아서 표시한다고 설명함
    
    연산결과에 대한 부가정보를 플래그 레지스터에 담아둠. 
    
    연산 결과가 레지스터에 담을 수 없을 정도로 커지면 그것또한 플래그에 overflow로 담김
    
    | 플래그 종류 | 의미 | 사용예시 |
    | --- | --- | --- |
    | 부호 플래그 | 연산한 결과의 부호를 나타낸다 | 부호 플래그가 1일 경우 계산결과는 음수.
     0일 경우 양수를 의미한다. |
    | 제로 플래그 | 연산결과가 0인지 여부를 나타낸다 | 제로플래그가 1일 경우 연산결과는  0
    0일 경우 연산결과는 0이 아님을 의미한다.  |
    | 캐리 플래그 | 연산결과 올림수나 빌림수가 발생했는지를 나타낸다.  | 캐리 플래그가 1일 경우 올림수나 빌림수가 발생
    했음을 의미하고, 0일 경우 발생하지 않았음을
    의미한다.  |
    | 오버플로우 플래그 | 오버플로우가 발생했는지를 나타낸다.  | 오버플로우 플래그가 1일 경우 오버플로우가 발생
    했음을 의미하고, 0일 경우 발생하지 않았음을
    의미한다.  |
    | 인터럽트 플래그 | 인터럽트가 가능한지를 나타낸다. | 인터럽트 플래그가 1일 경우 인터럽트가 가능함을 
    의미하고, 0일 경우 인터럽트가 불가능함을 의미한다. |
    | 슈퍼바이저 플래그 | 커널모드로 실행중인지, 사용자 모드로 실행중인지를 나타낸다. | 슈퍼바이저 플래그가 1일 경우 커널모드로 실행중임을 의미하고, 0일 경우 사용자 모드로 실행중임을 의미한다.  |
    
    | 부호플래그 | 제로플래그 | 캐리플래그 | 오버플로우 | 인터럽트 | 슈퍼바이저 |
    | --- | --- | --- | --- | --- | --- |
    | 1 | 0 | 0 | 0 | 0 | 0 |
    
    이런식으로 플래그에 저장됨
    
    ### 제어장치
    
    ![스크린샷 2024-05-24 오전 9.43.12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/7e74c6d9-f5c0-4ac9-977d-e16427ca4f44/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.43.12.png)
    
    쿨럭
    
    ![스크린샷 2024-05-24 오전 9.57.32.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/fc30e263-d2c1-454d-9d12-9eabf5c3b9ce/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.57.32.png)
    
    컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간단위
    
    명령어 레지스터에는 해석할 명령어어가 저장되어 다음 명령어가 나온다. 
    
    입출력장치, 메모리 등에 할지 말지를 정하는 명령어를 내보냄. 
    
    제어신호는 내부에 제어신호와 외부에 제어신호가 있고, 받아오는 제어신호가 있다. 
    
    내보내는 제어신호도 레지스터로 내보내는게 있고, ALU에 내보내는 신호가 있다. 
    
- 레지스터
    
    레지스터는 cpu 내부의 작은 임시저장장치 
    
    프로그램 속 명령어 & 데이터는 실행 전후로 레지스터에 저장
    
    프로그래머 입장에서는 중요한 역할을 한다. 
    
    cpu 내부에는 다양한 레지스터들이 있고, 각기 다른 역할을 가진다. 
    
    - 프로그램 카운터
        
        - 메모리에서 가져올 명령어의 주소(메모리에서 읽어 들잉 명령어의 주소)
        
        ![스크린샷 2024-05-24 오후 4.22.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/cd8e7807-f607-4b2d-8cdc-684ecdda3634/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.22.21.png)
        
    - 명령어 레지스터
        
        - 해석할 명령어(방금 메모리에서 읽어들인 명령어)
        
    - 메모리 주소 레지스터
        
         - 메모리의 주소를 저장(cpu가 읽어들이고자 하는 주소를 주소버스로 보낼 때 거치는 레지스터
        
    - 메모리 버퍼 레지스터
        
        - 메모리와 주고받을값(데이터와 명령어)
        
        프로그램 카운터가 메모리에 찾을 주소를 찾음 → 메모리 주소를 보고 메모리 주소 레지스터가 확인을함 → 동시에 제어장치에 제어신호가 메모리를 읽음. → 이때 프로그램 카운터가 1001로 1올라감 
        
        ![스크린샷 2024-05-24 오후 4.25.39.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/ce950d6e-a9e8-44e4-90a7-f2d91d03e44f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.25.39.png)
        
        이런 결과가 나오게됨
        
        프로그램 카운터는 이런 순환을 끝내고 1이 올라가는데 이것이 프로그램이 순차적으로 실행시킬 수 있는 원리임. 
        
        순차적인 실행 흐름이 끊기는 경우
        
        - 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시
        - 인터럽트 발생 시
        - 기타 사항.
    - 플래그 레지스터
        
        연산 결과 또는 CPU 상태에 대한 부가적인 정보
        
    - 범용 레지스터
        
        다양하고 일반적인 상황에서 자유롭게 사용
        
    
    아래는 주소 지정방식
    
    - 스택 포인터
        
        스택포인터 : 스택의 꼭대기 가리키는 레지스터(스택이 어디까지 차 있는지에 대한 표시)
        
    - 베이스 레지스터
        
        기준 주소 저장
        
    
    *cpu 종류마다 레지스터 종류는 다릅니다. 
    
    특정 레지스터를 이용한 주소 지정방식
    
    ### 스택 주소지정 방식 : 스택과 스택 포인터를 이용한 주소 지정방식
    
    ![스크린샷 2024-05-24 오후 4.34.03.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/b2736a49-2c9d-44d5-8cab-8cf5fe676d55/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.34.03.png)
    
    ### 변위 주소 지정 방식
    
    - 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효주소얻기
        
        ![스크린샷 2024-05-24 오후 4.37.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/d487b395-e474-47f0-9428-03772e5c354c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.37.21.png)
        
        ![스크린샷 2024-05-24 오후 4.38.39.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/9f5c2c09-7af0-438a-a7e1-d57ae5283317/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.38.39.png)
        
        - 상대 주소지정방식 : 오퍼랜드 필드의 값과 프로그램 카운터의 값을 더하여 유효주소얻기
        
        ![스크린샷 2024-05-24 오후 4.40.52.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/9e5e40c9-3c01-4556-8516-8b9cd1fab7f3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.40.52.png)
        
        프로그램 카운터 값에 -3을 더해서 실행할 명령어 위치를 가져오는 값. 
        
        - 베이스 레지스터 주소 지정 방식 : 오퍼랜드 필드의 값(변위)과 베이스 레지스터의 값을 더하여 유효주소 얻기.
        
        ![스크린샷 2024-05-24 오후 4.50.13.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/d3dc6412-e014-4968-a7bf-6163658e993e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.50.13.png)
        
        200번 주소에서 베이스 레지스터 50번지 떨어진 코드를 실행한다. 
        
- 명령어 사이클과 인터럽트
    
    cpu는 메모리의 프로그램을 정해진 주기대로 처리한다. 이게 명령어 사이클
    
    정해진 흐름대로만 처리하는데 이걸 방해하거나, 끊는 신호를 ‘인터럽트라고 한다. 
    
    명령어 사이클 : 프로그램 속 명령어들은 일정한 주기가 반복되며 실행, 이 주기를 명령어 사이클이라고 함.
    
    인출 사이클 : 가장 먼저 cpu로 갖고와야한다. 
    
    실행 사이클 : 갖고 왔으면 실행해야 한다. 
    
    일반적으로 ‘ 인출 - 실행 - 인출 - 실행 - 인출을 반복한다 .
    
    근데 간접 주소지정방식 같은경우는 cpu가 명령어를 가지고와도 바로 실행이 불가능 한 경우가 있다. 
    
    그런경우에는  
    
    ![스크린샷 2024-05-27 오후 5.09.06.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2d937bb9-6baa-4f98-93bc-1f40351ef1b7/3971c6a6-fa43-48b4-99cc-6e45b67314dc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-05-27_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.09.06.png)
    
    이런식으로 간접사이클이 필요하다. 
    
    인출, 간접, 실행 사이클을 거쳐서 실행된다. 
    
    인터럽트 - 방해하다. 중단시키다. 
    
    cpu가 꼭 주목해야할 때,cpu가 얼느 처리해야할 다른 작업이 생겼을 때 발생. 
    
    인터럽트의 종류
    
    동기 인터럽트(예외)
    
    - cpu가 예기치 못한 상황을 접했을 떄 발생( 실행을 중단하고 처리해야하는 상황)
        - 폴트
        - 트랩
        - 중단
        - 소프트웨어 인터럽트
        
    
    비동기 인터럽트(하드웨어 인터럽트)
    
    - 주로 입출력 장치에 의해 발생, 알림과 같은 역할
    
    알림과도 같은 인터럽트
    
    입출력작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트 사용
    
    입출력 장치는 cpu에 비해 느리다. 
    
    인터럽트가 없다면 cpu는 프린트 완료 여부를 확인하기 위해 주기적으로 확인해야한다. 
    
    인터럽트가 있다면 입출력 작업동안 cpu는 다른 일을 할 수 있다. 
    
    인터럽트의 처리순서
    
    1. 입출력장치는 cpu에 인터럽트 요청신호를 보냅니다. 
    2. cpu는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인합니다. 
    3. cpu는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인합니다. 
    4. 인터럽트를 받아들일 수 있다면 cpu는 지금까지의 작업을 백업합니다. 
    5. cpu는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행합니다
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에세 백업해둔 작업을 복구하여 실행을 재개합니다. 
    
    인터럽트 요청신호 : 입출력장치가 지금 끼어들어도 되는지 요청신호를 보낸다. 
    
    cpu는 요청신호를 받아드리면 
    
    
    이 사진 인터럽트 플래그에 요청신호를 받아들일 수 있는지 없는지 표시한다. 
    
    물론, 모든 인터럽트를 플래그로 막을 수 있는건 아니다. 너무 긴급한 인터럽트는 바로 실행됨
    
    즉, 비동기 인터럽트는 
    
    막을 수 있는 인터럽트
    
    막을 수 없는 인터럽트로 나뉜다고 볼 수 있다. 
    
    요청신호를 받아들인다면, 인터럽트 서비스 루틴을 실행한다. 
    
    - 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하기 위한 프로그램
    - 인터럽트 서비스 루틴도 프로그램이기 때문에 메모리에 저장함.
    
    
    cpu가 그럼 각각의 인터럽트를 구분해야하는데 이걸 ‘인터럽트 백터’라고 부른다. 
    
    “cpu가 인터럽트를 처리한다.” → 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다. 그리고 인터럽트의 시작주소는 백터를 통해 알 수 있다. 
    
    인터럽트의 지금까지 작업내용은 스택에 백업을 해둔다. 
    
    